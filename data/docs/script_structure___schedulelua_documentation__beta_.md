# Script Structure | ScheduleLua Documentation (Beta)

# Script Structure [​](#script-structure) This guide covers the recommended structure for ScheduleLua scripts, explaining the key components and organization patterns to help you write clean, maintainable scripts. ## Basic Script Structure [​](#basic-script-structure) A well-structured ScheduleLua script typically includes these key sections: * Header comment block* Global variables* Lifecycle hook functions* Helper functions* Custom event handlers Here&#39;s a skeleton template that you can use as a starting point: lua --[[ ScriptName.lua Description: Brief description of what this script does Author: Your Name Version: 1.0 ]] -- Global variables and state local someState = nil local someOtherState = false local lastUpdate = 0 -- Initialize function - called when script is loaded function Initialize () Log ( &quot;Script initializing...&quot; ) -- Setup code here end -- Update function - called every frame function Update () -- Performance optimization: Only run expensive operations every 10 frames if Time. frameCount - lastUpdate &lt; 10 then return end lastUpdate = Time. frameCount -- Main update logic here end -- Console ready hook function OnConsoleReady () -- Register commands RegisterCommand ( &quot;mycommand&quot; , &quot;Description&quot; , &quot;usage&quot; , CommandHandler) end -- Player ready hook function OnPlayerReady () -- Player initialization someState = GetPlayerPosition () Log ( &quot;Player ready at position: &quot; .. someState. x .. &quot;, &quot; .. someState. y .. &quot;, &quot; .. someState. z ) end -- Other lifecycle hooks function OnSceneLoaded (sceneName) -- Scene-specific logic end function OnDayChanged (day) -- Day change logic end -- Command handlers function CommandHandler (args) -- Handle command logic Log ( &quot;Command executed with args: &quot; .. table.concat (args, &quot;, &quot; )) end -- Custom helper functions function CalculateSomething (value1, value2) return value1 * value2 end -- Custom event handlers function OnCustomEvent () -- Handle custom events end -- Shutdown function - called when script is unloaded function Shutdown () -- Cleanup code UnregisterCommand ( &quot;mycommand&quot; ) Log ( &quot;Script shutdown complete&quot; ) end ## Organizing State Management [​](#organizing-state-management) For complex scripts, it&#39;s often helpful to group related state variables into tables: lua -- Player state tracking local playerState = { position = nil , health = 100 , energy = 100 , region = nil , inventory = {} } -- NPC tracking local npcState = { tracked = {}, lastInteraction = nil } -- Game state tracking local gameState = { time = 0 , day = 1 , isNight = false } This approach makes it easier to pass state around and keep related data organized. ## Handling Commands [​](#handling-commands) When registering multiple commands, it&#39;s best to group them together in the OnConsoleReady function: lua function OnConsoleReady () -- Player information commands RegisterCommand ( &quot;pos&quot; , &quot;Shows player position&quot; , &quot;pos&quot; , CommandPosition) RegisterCommand ( &quot;health&quot; , &quot;Shows player health&quot; , &quot;health&quot; , CommandHealth) -- World information commands RegisterCommand ( &quot;time&quot; , &quot;Shows current game time&quot; , &quot;time&quot; , CommandTime) RegisterCommand ( &quot;npcs&quot; , &quot;Shows nearby NPCs&quot; , &quot;npcs [radius]&quot; , CommandNPCs) -- Utility commands RegisterCommand ( &quot;help&quot; , &quot;Shows available commands&quot; , &quot;help&quot; , CommandHelp) end function CommandPosition (args) local pos = GetPlayerPosition () Log ( &quot;Position: &quot; .. pos. x .. &quot;, &quot; .. pos. y .. &quot;, &quot; .. pos. z ) end function CommandHealth (args) Log ( &quot;Health: &quot; .. GetPlayerHealth ()) end -- Other command handlers... ## Managing Complex Update Logic [​](#managing-complex-update-logic) For scripts with complex update logic, split the functionality into separate functions: lua function Update () -- Only run expensive checks every few frames if Time. frameCount % 5 == 0 then CheckPlayerStatus () end -- Run less frequently if Time. frameCount % 30 == 0 then CheckWorldState () end -- Always run HandleImportantEvents () end function CheckPlayerStatus () -- Player status checking logic end function CheckWorldState () -- World state checking logic end function HandleImportantEvents () -- Critical event handling end ## Conditional Feature Enablement [​](#conditional-feature-enablement) For scripts with multiple features that can be enabled/disabled: lua -- Configuration local config = { enablePlayerTracking = true , enableNPCTracking = true , enableEconomyFeatures = false , logLevel = &quot;normal&quot; -- &quot;minimal&quot;, &quot;normal&quot;, &quot;verbose&quot; } function Initialize () Log ( &quot;Initializing with configuration:&quot; ) Log ( &quot;- Player Tracking: &quot; .. (config. enablePlayerTracking and &quot;Enabled&quot; or &quot;Disabled&quot; )) Log ( &quot;- NPC Tracking: &quot; .. (config. enableNPCTracking and &quot;Enabled&quot; or &quot;Disabled&quot; )) Log ( &quot;- Economy Features: &quot; .. (config. enableEconomyFeatures and &quot;Enabled&quot; or &quot;Disabled&quot; )) if config. enablePlayerTracking then InitPlayerTracking () end if config. enableNPCTracking then InitNPCTracking () end return true end function Update () if config. enablePlayerTracking then UpdatePlayerTracking () end if config. enableNPCTracking then UpdateNPCTracking () end end ## Error Handling [​](#error-handling) Proper error handling is important for script stability: lua function TryGetNPC (npcName) if not npcName or npcName == &quot;&quot; then LogError ( &quot;Invalid NPC name&quot; ) return nil end local npc = FindNPC (npcName) if not npc then LogWarning ( &quot;Could not find NPC: &quot; .. npcName) return nil end return npc end -- Usage with error handling function InteractWithNPC (npcName) local npc = TryGetNPC (npcName) if not npc then return false end -- Safe to proceed with NPC interaction Log ( &quot;Interacting with NPC: &quot; .. npc. fullName ) return true end ## Script Performance Optimization [​](#script-performance-optimization) For optimal performance, particularly in the Update function: * Throttle operations - Only perform expensive operations every X frames* Cache results - Store and reuse values that don&#39;t change frequently* Check conditions early - Return early if conditions aren&#39;t met* Use efficient data structures - Choose appropriate tables and access patterns* Minimize string operations - String concatenation can be expensive when done frequently lua -- Example of performance optimization local lastCheck = 0 local cachedResult = nil function ExpensiveOperation () -- Only run every 30 frames if Time. frameCount - lastCheck &lt; 30 then return cachedResult end lastCheck = Time. frameCount -- Perform expensive calculation cachedResult = CalculateResult () return cachedResult end ## Best Practices [​](#best-practices) * Keep scripts focused - Each script should have a clear, specific purpose* Use comments - Document complex logic and the &quot;why&quot; behind your code* Use local variables - Avoid globals to prevent conflicts with other scripts* Follow naming conventions : Use camelCase for variables and functions* Use PascalCase for lifecycle hooks* Use descriptive names that indicate purpose * Structure for readability - Group related functions together* Test thoroughly - Test scripts under various game conditions* Clean up resources - Always implement Shutdown() to clean up By following these structural patterns and best practices, you&#39;ll create ScheduleLua scripts that are easier to maintain, debug, and extend.